package ci

// generated by kitool v3.7.19
import (
	"context"
	"errors"
	"fmt"

	"code.byted.org/gopkg/thrift"
	"code.byted.org/kite/endpoint"
	"code.byted.org/kite/kitc"

	"ci/thrift_gen/base"
	"ci/thrift_gen/code/factory/ci"
)

var (
	responseBuilder map[string]func() thrift.TStruct
)

func init() {
	responseBuilder = map[string]func() thrift.TStruct{

		"FetchTargetRepoLastCommit": func() thrift.TStruct {
			return &ci.FetchTargetRepoLastCommitResonse{}
		},

		"IsTargetRepoUpdated": func() thrift.TStruct {
			return &ci.IsTargetRepoUpdatedResponse{}
		},
	}
	kitc.Register("code.factory.ci", &KitcCodeFactoryCiServiceClient{})

}

func GetResponseBuilder() (string, map[string]func() thrift.TStruct) {
	return "code.factory.ci", responseBuilder
}

type Client struct {
	kc *kitc.KitcClient
}

// Name returns the PSM string used on client's creation.
func (c *Client) Name() string {
	return c.kc.Name()
}

func NewClient(PSM string, options ...kitc.Option) (*Client, error) {
	kc, err := kitc.NewWithThriftClient(PSM, &KitcCodeFactoryCiServiceClient{}, options...)
	return &Client{kc}, err
}

func MustNewClient(PSM string, options ...kitc.Option) *Client {
	client, err := NewClient(PSM, options...)
	if err != nil {
		panic(err)
	}
	return client
}

type CodeFactoryCiServiceClientBuilder interface {
	New() *ci.CodeFactoryCiServiceClient
}

type TCodeFactoryCiServiceClientBuilder struct {
	kc *kitc.KitcClient
}

func NewTCodeFactoryCiServiceClientBuilder(kc *kitc.KitcClient) *TCodeFactoryCiServiceClientBuilder {
	return &TCodeFactoryCiServiceClientBuilder{
		kc: kc,
	}
}

func (c *TCodeFactoryCiServiceClientBuilder) New() *ci.CodeFactoryCiServiceClient {
	t := kitc.NewBufferedTransport(c.kc)
	f := thrift.NewTBinaryProtocolFactoryDefault()
	client := &ci.CodeFactoryCiServiceClient{
		Transport:       t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
	}
	return client
}

func (c *Client) FetchTargetRepoLastCommit(ctx context.Context, r *ci.FetchTargetRepoLastCommitRequest) (*KitcFetchTargetRepoLastCommitResonse, error) {
	if c.kc == nil {
		return nil, errors.New("Client is not initialized")
	}
	ctx, err := c.kc.MethodInit("FetchTargetRepoLastCommit", ctx, r)
	if err != nil {
		return nil, err
	}
	next := mkFetchTargetRepoLastCommit(NewTCodeFactoryCiServiceClientBuilder(c.kc))
	request := &KiteFetchTargetRepoLastCommitRequest{r}
	resp, err := c.kc.MethodCall(next, ctx, request)
	kitcResp, ok := resp.(*KitcFetchTargetRepoLastCommitResonse)
	if !ok {
		if resp != nil && err == nil {
			return nil, fmt.Errorf("Response type assertion failure: %T to %v", resp, "*KitcFetchTargetRepoLastCommitResonse")
		}
		return nil, err
	}
	return kitcResp, err

}

func (c *Client) IsTargetRepoUpdated(ctx context.Context, r *ci.IsTargetRepoUpdatedRequest) (*KitcIsTargetRepoUpdatedResponse, error) {
	if c.kc == nil {
		return nil, errors.New("Client is not initialized")
	}
	ctx, err := c.kc.MethodInit("IsTargetRepoUpdated", ctx, r)
	if err != nil {
		return nil, err
	}
	next := mkIsTargetRepoUpdated(NewTCodeFactoryCiServiceClientBuilder(c.kc))
	request := &KiteIsTargetRepoUpdatedRequest{r}
	resp, err := c.kc.MethodCall(next, ctx, request)
	kitcResp, ok := resp.(*KitcIsTargetRepoUpdatedResponse)
	if !ok {
		if resp != nil && err == nil {
			return nil, fmt.Errorf("Response type assertion failure: %T to %v", resp, "*KitcIsTargetRepoUpdatedResponse")
		}
		return nil, err
	}
	return kitcResp, err

}

type KitcCodeFactoryCiServiceClient struct{}

func (c *KitcCodeFactoryCiServiceClient) New(kc *kitc.KitcClient) kitc.Caller {
	cb := NewTCodeFactoryCiServiceClientBuilder(kc)
	return &KitcCodeFactoryCiServiceCaller{cb}
}

type KitcCodeFactoryCiServiceCaller struct {
	cb CodeFactoryCiServiceClientBuilder
}

func (c *KitcCodeFactoryCiServiceCaller) Call(name string, request interface{}) (endpoint.EndPoint, endpoint.KitcCallRequest) {
	switch name {

	case "FetchTargetRepoLastCommit":
		return mkFetchTargetRepoLastCommit(c.cb), &KiteFetchTargetRepoLastCommitRequest{request.(*ci.FetchTargetRepoLastCommitRequest)}

	case "IsTargetRepoUpdated":
		return mkIsTargetRepoUpdated(c.cb), &KiteIsTargetRepoUpdatedRequest{request.(*ci.IsTargetRepoUpdatedRequest)}

	}
	panic(fmt.Errorf("method %v not found, please check Call name", name))
}

type KiteFetchTargetRepoLastCommitRequest struct {
	*ci.FetchTargetRepoLastCommitRequest
}

func (kr *KiteFetchTargetRepoLastCommitRequest) RealRequest() interface{} {
	return kr.FetchTargetRepoLastCommitRequest
}

func (kr *KiteFetchTargetRepoLastCommitRequest) SetBase(kb endpoint.KiteBase) error {

	kr.FetchTargetRepoLastCommitRequest.Base = &base.Base{
		LogID:  kb.GetLogID(),
		Caller: kb.GetCaller(),
		Addr:   kb.GetAddr(),
		Client: kb.GetClient(),
		Extra: map[string]string{
			"cluster": kb.GetCluster(),
			"env":     kb.GetEnv(),
		},
	}

	return nil
}

func (kr *KiteFetchTargetRepoLastCommitRequest) SetBaseExtra(key, value string) {

	if kr.FetchTargetRepoLastCommitRequest.Base == nil {
		return
	}

	if kr.FetchTargetRepoLastCommitRequest.Base.Extra == nil {
		return
	}
	kr.FetchTargetRepoLastCommitRequest.Base.Extra[key] = value

}

type KiteIsTargetRepoUpdatedRequest struct {
	*ci.IsTargetRepoUpdatedRequest
}

func (kr *KiteIsTargetRepoUpdatedRequest) RealRequest() interface{} {
	return kr.IsTargetRepoUpdatedRequest
}

func (kr *KiteIsTargetRepoUpdatedRequest) SetBase(kb endpoint.KiteBase) error {

	kr.IsTargetRepoUpdatedRequest.Base = &base.Base{
		LogID:  kb.GetLogID(),
		Caller: kb.GetCaller(),
		Addr:   kb.GetAddr(),
		Client: kb.GetClient(),
		Extra: map[string]string{
			"cluster": kb.GetCluster(),
			"env":     kb.GetEnv(),
		},
	}

	return nil
}

func (kr *KiteIsTargetRepoUpdatedRequest) SetBaseExtra(key, value string) {

	if kr.IsTargetRepoUpdatedRequest.Base == nil {
		return
	}

	if kr.IsTargetRepoUpdatedRequest.Base.Extra == nil {
		return
	}
	kr.IsTargetRepoUpdatedRequest.Base.Extra[key] = value

}

type KitcFetchTargetRepoLastCommitResonse struct {
	*ci.FetchTargetRepoLastCommitResonse
	addr string
}

func (kp *KitcFetchTargetRepoLastCommitResonse) GetBaseResp() endpoint.KiteBaseResp {
	if kp.FetchTargetRepoLastCommitResonse != nil {
		if ret := kp.FetchTargetRepoLastCommitResonse.GetBaseResp(); ret != nil {
			return ret
		}
	}
	return nil
}

func (kp *KitcFetchTargetRepoLastCommitResonse) RemoteAddr() string {
	return kp.addr
}

func (kp *KitcFetchTargetRepoLastCommitResonse) RealResponse() interface{} {
	return kp.FetchTargetRepoLastCommitResonse
}

func (kp *KitcFetchTargetRepoLastCommitResonse) TypedRealResponse() *ci.FetchTargetRepoLastCommitResonse {
	return kp.FetchTargetRepoLastCommitResonse
}

func (kp *KitcFetchTargetRepoLastCommitResonse) NilResponse() bool {
	return kp.FetchTargetRepoLastCommitResonse == nil
}

type KitcIsTargetRepoUpdatedResponse struct {
	*ci.IsTargetRepoUpdatedResponse
	addr string
}

func (kp *KitcIsTargetRepoUpdatedResponse) GetBaseResp() endpoint.KiteBaseResp {
	if kp.IsTargetRepoUpdatedResponse != nil {
		if ret := kp.IsTargetRepoUpdatedResponse.GetBaseResp(); ret != nil {
			return ret
		}
	}
	return nil
}

func (kp *KitcIsTargetRepoUpdatedResponse) RemoteAddr() string {
	return kp.addr
}

func (kp *KitcIsTargetRepoUpdatedResponse) RealResponse() interface{} {
	return kp.IsTargetRepoUpdatedResponse
}

func (kp *KitcIsTargetRepoUpdatedResponse) TypedRealResponse() *ci.IsTargetRepoUpdatedResponse {
	return kp.IsTargetRepoUpdatedResponse
}

func (kp *KitcIsTargetRepoUpdatedResponse) NilResponse() bool {
	return kp.IsTargetRepoUpdatedResponse == nil
}

func mkFetchTargetRepoLastCommit(cb CodeFactoryCiServiceClientBuilder) endpoint.EndPoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		client := cb.New()
		transport := client.Transport.(kitc.Transport)
		err := transport.OpenWithContext(ctx)
		if err != nil {
			return nil, err
		}
		defer transport.Close()

		resp, err := client.FetchTargetRepoLastCommit(request.(endpoint.KitcCallRequest).RealRequest().(*ci.FetchTargetRepoLastCommitRequest))
		addr := transport.RemoteAddr()
		return &KitcFetchTargetRepoLastCommitResonse{resp, addr}, err

	}
}

func mkIsTargetRepoUpdated(cb CodeFactoryCiServiceClientBuilder) endpoint.EndPoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		client := cb.New()
		transport := client.Transport.(kitc.Transport)
		err := transport.OpenWithContext(ctx)
		if err != nil {
			return nil, err
		}
		defer transport.Close()

		resp, err := client.IsTargetRepoUpdated(request.(endpoint.KitcCallRequest).RealRequest().(*ci.IsTargetRepoUpdatedRequest))
		addr := transport.RemoteAddr()
		return &KitcIsTargetRepoUpdatedResponse{resp, addr}, err

	}
}

func init() {

	kitc.SetIDL("code.factory.ci", "base.thrift", `namespace py base
namespace go base
namespace java com.bytedance.thrift.base

struct TrafficEnv {
    1: bool Open = false,
    2: string Env = "",
}

struct Base {
    1: string LogID = "",
    2: string Caller = "",
    3: string Addr = "",
    4: string Client = "",
    5: optional TrafficEnv TrafficEnv,
    6: optional map<string, string> Extra,
}

struct BaseResp {
    1: string StatusMessage = "",
    2: i32 StatusCode = 0,
    3: optional map<string, string> Extra,
}
`)

	kitc.SetIDL("code.factory.ci", "code_factory_ci.thrift", `namespace py code.factory.ci
namespace go code.factory.ci

include "base.thrift"

struct IsTargetRepoUpdatedRequest {
    1:      optional i64 RepoId,
    255:    base.Base Base
}

struct IsTargetRepoUpdatedResponse {
    1:      optional bool IsUpdated,
    255:    base.BaseResp BaseResp
}

struct FetchTargetRepoLastCommitRequest {
    1:      optional i64 RepoId,
    255:    base.Base Base
}

struct CommitStruct {
    1: optional i64 Id,
    2: optional string  Msg,
    3: optional string Author,
    4: optional i64 LastUpdateTime
}

struct FetchTargetRepoLastCommitResonse {
    1:      optional CommitStruct Commit,
    255:    base.BaseResp BaseResp
}

service CodeFactoryCiService {
    IsTargetRepoUpdatedResponse         IsTargetRepoUpdated         (1: IsTargetRepoUpdatedRequest req),
    FetchTargetRepoLastCommitResonse    FetchTargetRepoLastCommit   (1: FetchTargetRepoLastCommitRequest req)
}
`)

}
